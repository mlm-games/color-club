func process_svg_path(element:XMLParser) -> void:
        print("Processing path with d=", element.get_named_attribute_value("d"))

        var element_string = element.get_named_attribute_value("d")
        for symbol in ["m", "M", "v", "V", "h", "H", "l", "L", "c", "C", "s", "S", "z", "Z"]:
                element_string = element_string.replacen(symbol, " " + symbol + " ")
        element_string = element_string.replacen(",", " ")

        print("Processed element string:", element_string)

        #split element string into multiple arrays
        var element_string_array = element_string.split(" ", false)
        var string_arrays = []
        var string_array : PackedStringArray

        for a in element_string_array:
                if a in ["m", "M"]:
                        if string_array.size() > 0:
                                string_arrays.append(string_array)
                        string_array = PackedStringArray()
                string_array.append(a)

        if string_array.size() > 0:
                string_arrays.append(string_array)

        print("Number of path segments:", string_arrays.size())
        for arr in string_arrays:
                print("Path segment:", arr)

        #convert into Line2Ds
        var string_array_count = -1
        for current_array in string_arrays:
                var cursor = Vector2.ZERO
                var points : PackedVector2Array
                var curve = Curve2D.new()
                string_array_count += 1

                for i in current_array.size()-1:
                        match current_array[i]:
                                "m":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)
                                                i += 2
                                "M":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor = Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)

                                                curve.add_point(Vector2(float(current_array[i+1]), float(current_array[i+2])))

                                                i += 2
                                "v":
                                        while current_array[i+1].is_valid_float():
                                                cursor.y += float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "V":
                                        while current_array[i+1].is_valid_float():
                                                cursor.y = float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "h":
                                        while current_array[i+1].is_valid_float():
                                                cursor.x += float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "H":
                                        while current_array[i+1].is_valid_float():
                                                cursor.x = float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "l":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)
                                                i += 2
                                "L":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor = Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)
                                                i += 2
                                #simpify Bezier curves with straight line
                                "c":
                                        while current_array.size() > i + 6 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+5]), float(current_array[i+6]))
                                                points.append(cursor)
                                                i += 6
                                "C":
                                        while current_array.size() > i + 6 and current_array[i+1].is_valid_float():
                                                var controll_point_in = Vector2(float(current_array[i+5]), float(current_array[i+6])) - cursor
                                                cursor = Vector2(float(current_array[i+5]), float(current_array[i+6]))
                                                points.append(cursor)
                                                curve.add_point(        cursor,
                                                                                        -cursor + Vector2(float(current_array[i+3]), float(current_array[i+4])),
                                                                                        cursor - Vector2(float(current_array[i+3]), float(current_array[i+4]))
                                                                                )
                                                i += 6
                                "s":
                                        while current_array.size() > i + 4 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+3]), float(current_array[i+4]))
                                                points.append(cursor)
                                                i += 4
                                "S":
                                        while current_array.size() > i + 4 and current_array[i+1].is_valid_float():
                                                cursor = Vector2(float(current_array[i+3]), float(current_array[i+4]))
                                                points.append(cursor)
                                                i += 4

                if use_path2d and curve.get_point_count() > 1:
                        create_path2d(  element.get_named_attribute_value("id") + "_" + str(string_array_count),
                                                        current_node,
                                                        curve,
                                                        get_svg_transform(element),
                                                        get_svg_style(element))

                elif string_array[string_array.size()-1].to_upper() == "Z": #closed polygon
                        create_polygon2d(       element.get_named_attribute_value("id") + "_" + str(string_array_count),
                                                                current_node,
                                                                points,
                                                                get_svg_transform(element),
                                                                get_svg_style(element))
                else:
                        create_line2d(  element.get_named_attribute_value("id") + "_" + str(string_array_count),
                                                        current_node,
                                                        points,
                                                        get_svg_transform(element),
                                                        get_svg_style(element))


func create_path2d(     name:String,
                                        parent:Node,
                                        curve:Curve2D,
                                        transform:Transform2D,
                                        style:Dictionary) -> void:
        var new_path = Path2D.new()
        new_path.name = name
        new_path.transform = transform
        parent.add_child(new_path)
        new_path.owner = root_node
        new_path.curve = curve

        #style
        if style.has("stroke"):
                new_path.modulate = Color(style["stroke"])
#       if style.has("stroke-width"):
#               new_path.width = float(style["stroke-width"])


func create_line2d(     name:String,
                                        parent:Node,
                                        points:PackedVector2Array,
                                        transform:Transform2D,
                                        style:Dictionary) -> void:
        var new_line = Line2D.new()
        new_line.name = name
        new_line.transform = transform
        parent.add_child(new_line)
        new_line.owner = root_node
        new_line.points = points

        #style
        if style.has("stroke"):
                new_line.default_color = Color(style["stroke"])
        if style.has("stroke-width"):
                #var line = Line2D.new()
                new_line.width = float(style["stroke-width"])
                #new_path.add_child(line)
                #
                ## Sample points along curve
                #var curve_points = []
                #var step = 0.1
                #for i in range(0, 1.0, step):
                        #points.append(curve.interpolate(i))
                #line.points = points


func create_polygon2d(  name:String,
                                                parent:Node,
                                                points:PackedVector2Array,
                                                transform:Transform2D,
                                                style:Dictionary) -> void:
        var new_poly
        #style
        if style.has("fill") and style["fill"] != "none":
                #create base
                new_poly = Polygon2D.new()
                new_poly.name = name
                parent.add_child(new_poly)
                new_poly.owner = root_node
                new_poly.transform = transform
                new_poly.polygon = points
                new_poly.color = Color(style["fill"])

        if style.has("stroke") and style["stroke"] != "none":
                #create outline
                var new_outline = Line2D.new()
                new_outline.name = name + "_stroke"
                if new_poly:
                        new_poly.add_child(new_outline)
                else:
                        parent.add_child(new_outline)
                        new_outline.transform = transform
                new_outline.owner = root_node
                points.append(points[0])
                new_outline.points = points

                new_outline.default_color = Color(style["stroke"])
                if style.has("stroke-width"):
                        new_outline.width = float(style["stroke-width"])

Just tell me what is missing, thats it.

Based on the code shown, there appear to be a few undefined variables/references that would be needed for this code to work properly:

    use_path2d - Used in the condition check but not defined in the shown code
    current_node - Used when creating new nodes but not defined
    root_node - Used for setting owner but not defined
    get_svg_transform() - Function is called but not shown in the code
    get_svg_style() - Function is called but not shown in the code

These would need to be defined elsewhere in the codebase for this SVG path processing code to function correctly.

What do these function do differently?


func _parse_element(xml: XMLParser, svg_elements: Array, id_map: Dictionary) -> int:
        var svg_element: PGParsedSVGElement = PGParsedSVGElement.new()
        svg_elements.append(svg_element)

        if xml.has_attribute("inkscape:label"):
                svg_element.name = xml.get_named_attribute_value_safe("inkscape:label")
        elif xml.has_attribute("id"):
                svg_element.name = xml.get_named_attribute_value_safe("id")
        else:
                svg_element.name = xml.get_node_name()
        if xml.has_attribute("id"):
                id_map[xml.get_named_attribute_value_safe("id")] = svg_element

        svg_element.transform = _parse_transform(xml.get_named_attribute_value_safe("transform"))
        _parse_style(xml, svg_element.style)

        svg_element.tag = xml.get_node_name()


        match xml.get_node_name():
                "path":
                        return _parse_path(xml, svg_element)
                "rect":
                        return _parse_rect(xml, svg_element)
                "circle":
                        return _parse_circle(xml, svg_element)
                "ellipse":
                        return _parse_ellipse(xml, svg_element)
                "line":
                        return _parse_line(xml, svg_element)
                "polyline":
                        return _parse_polygon(xml, svg_element, false)
                "polygon":
                        return _parse_polygon(xml, svg_element, true)
                "g":
                        return _parse_group(xml, svg_element, id_map)









                _:
                        PGLog.log_warning("could not parse SVG tag '" + svg_element.tag + "', ignoring.", self)
                        svg_element.type = PARSED_ELEMENT_TYPE.UNKNOWN
                        xml.skip_section()
                        return OK


func _parse_path(xml: XMLParser, element: PGParsedSVGElement) -> int:
        element.type = PARSED_ELEMENT_TYPE.PATH

        element.path_segments = _parse_path_def(xml.get_named_attribute_value_safe("d"))
        xml.skip_section()
        return OK


func _parse_rect(xml: XMLParser, element: PGParsedSVGElement) -> int:
        element.type = PARSED_ELEMENT_TYPE.PATH
        var r: Rect2 = Rect2(float(xml.get_named_attribute_value_safe("x")), float(xml.get_named_attribute_value_safe("y")), float(xml.get_named_attribute_value_safe("width")), float(xml.get_named_attribute_value_safe("height")))
        var rx: float = float(xml.get_named_attribute_value_safe("rx"))
        var ry: float = float(xml.get_named_attribute_value_safe("ry"))


        if (rx && !ry):
                ry = rx
        if (ry && !rx):
                rx = ry


        if rx > 0.0 && ry > 0.0:
                element.path_segments = [[SEGMENT_TYPE.START, r.position + Vector2(rx, 0.0), 1], [SEGMENT_TYPE.LINEAR, r.position + Vector2(r.size.x - rx, 0.0)], [SEGMENT_TYPE.ARC, r.position + Vector2(r.size.x - rx, 0.0), r.position + Vector2(r.size.x - rx, ry), r.position + Vector2(r.size.x, ry), r.position + Vector2(r.size.x, ry)], [SEGMENT_TYPE.LINEAR, r.end - Vector2(0.0, ry)], [SEGMENT_TYPE.ARC, r.end - Vector2(0.0, ry), r.end - Vector2(rx, ry), r.end - Vector2(rx, 0.0), r.end - Vector2(rx, 0.0)], [SEGMENT_TYPE.LINEAR, r.position + Vector2(rx, r.size.y)], [SEGMENT_TYPE.ARC, r.position + Vector2(rx, r.size.y), r.position + Vector2(rx, r.size.y - ry), r.position + Vector2(0.0, r.size.y - ry), r.position + Vector2(0.0, r.size.y - ry)], [SEGMENT_TYPE.LINEAR, r.position + Vector2(0.0, ry)], [SEGMENT_TYPE.ARC, r.position + Vector2(0.0, ry), r.position + Vector2(rx, ry), r.position + Vector2(rx, 0.0), r.position + Vector2(rx, 0.0)]]
        else:
                element.path_segments = [[SEGMENT_TYPE.START, r.position, 1], [SEGMENT_TYPE.LINEAR, r.position + Vector2(r.size.x, 0.0)], [SEGMENT_TYPE.LINEAR, r.end], [SEGMENT_TYPE.LINEAR, r.position + Vector2(0.0, r.size.y)]]
        xml.skip_section()
        return OK

func _parse_circle(xml: XMLParser, element: PGParsedSVGElement) -> int:
        element.type = PARSED_ELEMENT_TYPE.PATH
        var c: Vector2 = Vector2(float(xml.get_named_attribute_value_safe("cx")), float(xml.get_named_attribute_value_safe("cy")))
        var r: float = float(xml.get_named_attribute_value_safe("r"))


        element.path_segments = [[SEGMENT_TYPE.START, c - Vector2(r, 0.0), 1], [SEGMENT_TYPE.ARC, c + Vector2(0.0, r), c, c + Vector2(r, 0.0), c + Vector2(r, 0.0)], [SEGMENT_TYPE.ARC, c - Vector2(0.0, r), c, c - Vector2(r, 0.0), c - Vector2(r, 0.0)]]

        xml.skip_section()
        return OK

func _parse_ellipse(xml: XMLParser, element: PGParsedSVGElement) -> int:
        element.type = PARSED_ELEMENT_TYPE.PATH
        var c: Vector2 = Vector2(float(xml.get_named_attribute_value_safe("cx")), float(xml.get_named_attribute_value_safe("cy")))
        var rx: float = float(xml.get_named_attribute_value_safe("rx"))
        var ry: float = float(xml.get_named_attribute_value_safe("ry"))

        element.path_segments = [[SEGMENT_TYPE.START, c - Vector2(rx, 0.0), 1], [SEGMENT_TYPE.ARC, c + Vector2(0.0, ry), c, c + Vector2(rx, 0.0), c + Vector2(rx, 0.0)], [SEGMENT_TYPE.ARC, c + Vector2(0.0, - ry), c, c + Vector2( - rx, 0.0), c + Vector2( - rx, 0.0)]]
        xml.skip_section()
        return OK

func _parse_line(xml: XMLParser, element: PGParsedSVGElement) -> int:
        element.type = PARSED_ELEMENT_TYPE.PATH
        var s: Vector2 = Vector2(float(xml.get_named_attribute_value_safe("x1")), float(xml.get_named_attribute_value_safe("y1")))
        var e: Vector2 = Vector2(float(xml.get_named_attribute_value_safe("x2")), float(xml.get_named_attribute_value_safe("y2")))

        element.path_segments = [[SEGMENT_TYPE.START, s, 0], [SEGMENT_TYPE.LINEAR, e]]
        xml.skip_section()
        return OK

func _parse_polygon(xml: XMLParser, element: PGParsedSVGElement, closed: bool) -> int:
        element.type = PARSED_ELEMENT_TYPE.PATH
        var first: bool = true
        var segments: Array = []
        var def: String = xml.get_named_attribute_value_safe("points")
        if points_regex.search(def):
                for inst in point_regex.search_all(def):
                        var p: Vector2 = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                        if first:
                                segments.push_back([SEGMENT_TYPE.START, p, 1 if closed else 0])
                                first = false
                        else:
                                segments.push_back([SEGMENT_TYPE.LINEAR, p])

        element.path_segments = segments
        xml.skip_section()
        return OK




func _parse_group(xml: XMLParser, element: PGParsedSVGElement, id_map: Dictionary) -> int:
        var err: int
        element.type = PARSED_ELEMENT_TYPE.GROUP
        var name: String = xml.get_node_name()

        if !xml.is_empty():
                err = xml.read()
                if err != OK:
                        return err
                while xml.get_node_type() != XMLParser.NODE_ELEMENT_END:
                        if xml.get_node_type() == XMLParser.NODE_ELEMENT:
                                err = _parse_element(xml, element.children, id_map)
                                if err != OK:
                                        return err
                        err = xml.read()
                        if err != OK:
                                return err

        if xml.get_node_name() != name:
                return ERR_FILE_CORRUPT
        return OK

These functions handle SVG parsing differently from the first code you showed. Here are the key differences:

    Structure and Organization:

    This code uses a more structured approach with a dedicated PGParsedSVGElement class
    Elements are parsed into a structured format first, rather than directly creating nodes
    Uses an enumerated type system (PARSED_ELEMENT_TYPE, SEGMENT_TYPE)

    Element Handling:

    Converts all shape types (rect, circle, ellipse, line, etc.) into path segments
    Uses a consistent format where everything is converted to paths with segments
    Has dedicated parsing for each SVG element type rather than just handling paths

    Group Support:

    Has explicit support for SVG groups (<g> elements) with _parse_group
    Maintains parent-child relationships between elements

    Path Data:

    Likely uses a more robust path definition parser (through _parse_path_def, not shown)
    Stores path data in a structured format rather than immediately creating nodes

    Error Handling:

    Includes error checking and returns status codes
    More robust handling of XML parsing errors

The first code you showed was more focused on immediate node creation in the scene tree, while this code is more about parsing and storing the SVG data in an intermediate format that can be used later.

Improve the first code based on the previous code and current code carefully


func _parse_path_def(def: String) -> Array:
        var c: Vector2 = Vector2.ZERO
        var q: Vector2 = Vector2.ZERO
        var p: Vector2 = Vector2.ZERO
        var s: Array = []
        var segments: Array = []


        var double_period_components: Array[String]
        for result in double_period_regex.search_all(def):
                double_period_components.push_back(result.get_string())

        if (double_period_components):


                var first_period_location: int
                var second_period_location: int
                var edited_double_component: String
                for double_component: String in double_period_components:
                        first_period_location = double_component.find(".", 0)
                        second_period_location = double_component.find(".", first_period_location + 1)

                        edited_double_component = double_component.insert(second_period_location, " ")



                        def = def.replace(double_component, edited_double_component)

        var path_commands: Array = path_split_regex.search_all(def)

        if path_regex.search(def):


                for cmd: RegExMatch in path_commands:
                        match cmd.get_string(0)[0]:
                                "A":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in arc_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = Vector2(float(inst.get_string(6)), float(inst.get_string(7)))
                                                var r: Vector2 = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                var a: float = float(inst.get_string(3)) * (PI / 180.0)
                                                var t: Vector2 = 0.5 * (e - p).rotated( - a)
                                                var dc: float = r.x * r.x * t.y * t.y + r.y * r.y * t.x * t.x
                                                if !is_zero_approx(dc):
                                                        dc = (r.x * r.x * r.y * r.y - r.x * r.x * t.y * t.y - r.y * r.y * t.x * t.x) / dc
                                                        if dc > 0.0:
                                                                dc = sqrt(dc)
                                                        else:
                                                                dc = 0.0
                                                else:
                                                        dc = 0.0
                                                if inst.get_string(4) != inst.get_string(5):
                                                        dc = - dc
                                                var ac: Vector2 = Vector2(dc * r.x * t.y / r.y, - dc * r.y * t.x / r.x).rotated(a) + 0.5 * (p + e)
                                                var rx: Vector2 = ac + r.x * Vector2.RIGHT.rotated(a)
                                                var ry: Vector2 = ac + r.y * (Vector2.UP if inst.get_string(5) == "0" else Vector2.DOWN).rotated(a)
                                                segments.push_back([SEGMENT_TYPE.ARC, rx, ac, ry, e])
                                                p = e
                                "a":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in arc_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = p + Vector2(float(inst.get_string(6)), float(inst.get_string(7)))
                                                var r: Vector2 = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                var a: float = float(inst.get_string(3)) * (PI / 180.0)
                                                var t: Vector2 = 0.5 * (e - p).rotated( - a)
                                                var dc: float = r.x * r.x * t.y * t.y + r.y * r.y * t.x * t.x
                                                if !is_zero_approx(dc):
                                                        dc = (r.x * r.x * r.y * r.y - r.x * r.x * t.y * t.y - r.y * r.y * t.x * t.x) / dc
                                                        if dc > 0.0:
                                                                dc = sqrt(dc)
                                                        else:
                                                                dc = 0.0
                                                else:
                                                        dc = 0.0
                                                if inst.get_string(4) != inst.get_string(5):
                                                        dc = - dc
                                                var ac: Vector2 = Vector2(dc * r.x * t.y / r.y, - dc * r.y * t.x / r.x).rotated(a) + 0.5 * (p + e)
                                                var rx: Vector2 = ac + r.x * Vector2.RIGHT.rotated(a)
                                                var ry: Vector2 = ac + r.y * (Vector2.UP if inst.get_string(5) == "0" else Vector2.DOWN).rotated(a)
                                                segments.push_back([SEGMENT_TYPE.ARC, rx, ac, ry, e])
                                                p = e
                                "C":
                                        q = Vector2.ZERO
                                        for inst in cube_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = Vector2(float(inst.get_string(5)), float(inst.get_string(6)))
                                                c = Vector2(float(inst.get_string(3)), float(inst.get_string(4)))
                                                segments.push_back([SEGMENT_TYPE.CUBIC, Vector2(float(inst.get_string(1)), float(inst.get_string(2))), c, e])
                                                p = e
                                                c -= p
                                "c":
                                        q = Vector2.ZERO

                                        for inst: RegExMatch in cube_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = p + Vector2(float(inst.get_string(5)), float(inst.get_string(6)))
                                                c = p + Vector2(float(inst.get_string(3)), float(inst.get_string(4)))
                                                segments.push_back([SEGMENT_TYPE.CUBIC, p + Vector2(float(inst.get_string(1)), float(inst.get_string(2))), c, e])
                                                p = e
                                                c -= p

                                "H":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in num_regex.search_all(cmd.get_string(0)):
                                                p.x = float(inst.get_string(1))
                                                segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "h":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in num_regex.search_all(cmd.get_string(0)):
                                                p.x += float(inst.get_string(1))
                                                segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "L":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in point_regex.search_all(cmd.get_string(0)):
                                                p = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "l":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in point_regex.search_all(cmd.get_string(0)):
                                                p += Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "M":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        var first: bool = true
                                        for inst in point_regex.search_all(cmd.get_string(0)):
                                                p = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                if first:
                                                        s = [SEGMENT_TYPE.START, p, 0]
                                                        segments.push_back(s)
                                                        first = false
                                                else:
                                                        segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "m":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        var first: bool = true
                                        for inst in point_regex.search_all(cmd.get_string(0)):
                                                p += Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                if first:
                                                        s = [SEGMENT_TYPE.START, p, 0]
                                                        segments.push_back(s)
                                                        first = false
                                                else:
                                                        segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "Q":
                                        c = Vector2.ZERO
                                        for inst in quad_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = Vector2(float(inst.get_string(3)), float(inst.get_string(4)))
                                                q = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                segments.push_back([SEGMENT_TYPE.QUADRIC, q, e])
                                                p = e
                                                q -= p
                                "q":
                                        c = Vector2.ZERO
                                        for inst in quad_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = p + Vector2(float(inst.get_string(3)), float(inst.get_string(4)))
                                                q = p + Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                segments.push_back([SEGMENT_TYPE.QUADRIC, q, e])
                                                p = e
                                                q -= p
                                "S":
                                        q = Vector2.ZERO
                                        for inst in quad_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = Vector2(float(inst.get_string(3)), float(inst.get_string(4)))
                                                var t: Vector2 = p - c
                                                c = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                segments.push_back([SEGMENT_TYPE.CUBIC, t, c, e])
                                                p = e
                                                c -= p
                                "s":
                                        q = Vector2.ZERO
                                        for inst in quad_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = p + Vector2(float(inst.get_string(3)), float(inst.get_string(4)))
                                                var t: Vector2 = p - c
                                                c = p + Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                segments.push_back([SEGMENT_TYPE.CUBIC, t, c, e])
                                                p = e
                                                c -= p
                                "T":
                                        c = Vector2.ZERO
                                        for inst in point_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                q = p - q
                                                segments.push_back([SEGMENT_TYPE.QUADRIC, q, e])
                                                p = e
                                                q -= p
                                "t":
                                        c = Vector2.ZERO
                                        for inst in point_regex.search_all(cmd.get_string(0)):
                                                var e: Vector2 = p + Vector2(float(inst.get_string(1)), float(inst.get_string(2)))
                                                q = p - q
                                                segments.push_back([SEGMENT_TYPE.QUADRIC, q, e])
                                                p = e
                                                q -= p
                                "V":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in num_regex.search_all(cmd.get_string(0)):
                                                p.y = float(inst.get_string(1))
                                                segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "v":
                                        c = Vector2.ZERO
                                        q = Vector2.ZERO
                                        for inst in num_regex.search_all(cmd.get_string(0)):
                                                p.y += float(inst.get_string(1))
                                                segments.push_back([SEGMENT_TYPE.LINEAR, p])
                                "Z", "z":
                                        if s.size():
                                                s[2] = 1
                                                c = Vector2.ZERO
                                                q = Vector2.ZERO
                                                p = s[1]
                                _:
                                        PGLog.log_warning("_parse_path_def unsupported path command '" + cmd.get_string(0)[0] + "'", self)
        else:
                PGLog.log_error("_parse_path_def " + def + " not valid/supported path def", self)
        return segments

Best of both worlds is preferred

Here's how I would improve the first code by incorporating elements from both approaches:

enum SEGMENT_TYPE {
    START,
    LINEAR,
    CUBIC,
    QUADRIC,
    ARC
}

class SVGElement:
    var name: String
    var type: String
    var transform: Transform2D
    var style: Dictionary
    var path_segments: Array
    var children: Array

func process_svg_path(element: XMLParser) -> SVGElement:
    var svg_element = SVGElement.new()
    svg_element.name = element.get_named_attribute_value_safe("id")
    svg_element.type = "path"
    svg_element.transform = _parse_transform(element.get_named_attribute_value_safe("transform"))
    svg_element.style = _parse_style(element)

    # Parse path data into segments
    svg_element.path_segments = _parse_path_def(element.get_named_attribute_value_safe("d"))

    return svg_element

func create_path_node(svg_element: SVGElement, parent: Node) -> Node:
    match svg_element.type:
        "path":
            if _should_use_path2d(svg_element):
                return _create_path2d(svg_element, parent)
            elif _is_closed_path(svg_element):
                return _create_polygon2d(svg_element, parent)
            else:
                return _create_line2d(svg_element, parent)
        _:
            push_warning("Unsupported SVG element type: " + svg_element.type)
            return null

func _create_path2d(svg_element: SVGElement, parent: Node) -> Path2D:
    var path = Path2D.new()
    path.name = svg_element.name
    path.transform = svg_element.transform

    var curve = Curve2D.new()
    for segment in svg_element.path_segments:
        match segment[0]: # SEGMENT_TYPE
            SEGMENT_TYPE.START:
                curve.add_point(segment[1]) # Position
            SEGMENT_TYPE.LINEAR:
                curve.add_point(segment[1])
            SEGMENT_TYPE.CUBIC:
                curve.add_point(segment[3], segment[1], segment[2]) # End point, control1, control2
            # Add other segment types...

    path.curve = curve
    _apply_style(path, svg_element.style)
    parent.add_child(path)
    return path

func _create_line2d(svg_element: SVGElement, parent: Node) -> Line2D:
    var line = Line2D.new()
    line.name = svg_element.name
    line.transform = svg_element.transform

    var points = PackedVector2Array()
    for segment in svg_element.path_segments:
        match segment[0]:
            SEGMENT_TYPE.START, SEGMENT_TYPE.LINEAR:
                points.append(segment[1])
            # Handle other segment types...

    line.points = points
    _apply_style(line, svg_element.style)
    parent.add_child(line)
    return line

func _create_polygon2d(svg_element: SVGElement, parent: Node) -> Node:
    var root = Node2D.new()
    root.name = svg_element.name
    root.transform = svg_element.transform
    parent.add_child(root)

    if svg_element.style.has("fill") and svg_element.style["fill"] != "none":
        var polygon = Polygon2D.new()
        var points = _segments_to_points(svg_element.path_segments)
        polygon.polygon = points
        polygon.color = Color(svg_element.style["fill"])
        root.add_child(polygon)

    if svg_element.style.has("stroke") and svg_element.style["stroke"] != "none":
        var outline = Line2D.new()
        var points = _segments_to_points(svg_element.path_segments)
        points.append(points[0]) # Close the path
        outline.points = points
        _apply_stroke_style(outline, svg_element.style)
        root.add_child(outline)

    return root

func _apply_style(node: Node, style: Dictionary) -> void:
    if style.has("stroke"):
        if node is Line2D:
            node.default_color = Color(style["stroke"])
        else:
            node.modulate = Color(style["stroke"])

    if style.has("stroke-width") and node is Line2D:
        node.width = float(style["stroke-width"])

func _segments_to_points(segments: Array) -> PackedVector2Array:
    var points = PackedVector2Array()
    for segment in segments:
        match segment[0]:
            SEGMENT_TYPE.START, SEGMENT_TYPE.LINEAR:
                points.append(segment[1])
            # Handle other segment types...
    return points

This improved version:

    Uses a proper enum for segment types
    Creates a dedicated SVGElement class for better data organization
    Separates parsing and node creation
    Provides better support for different path types (Path2D, Line2D, Polygon2D)
    Has more robust style handling
    Maintains better structure and organization
    Supports both filled and stroked paths
    Has better error handling

You would still need to implement:

    _parse_transform()
    _parse_style()
    _should_use_path2d()
    _is_closed_path()
    The complete path definition parser
    Support for other SVG elements (rect, circle, etc.)

This provides a good foundation that combines the immediate node creation of the first approach with the better organization and robustness of the second approach.

improve _parse_path_def first then the others (if the previous response by you is satisfactory then only improve _parse_path_def)

Here's an improved version of _parse_path_def that's more robust and maintainable:

class PathCommand:
    var command: String
    var params: Array

    func _init(cmd: String, parameters: Array = []):
        command = cmd
        params = parameters

const COMMAND_PARAMS = {
    "M": 2, "m": 2,  # moveto: x y
    "L": 2, "l": 2,  # lineto: x y
    "H": 1, "h": 1,  # horizontal lineto: x
    "V": 1, "v": 1,  # vertical lineto: y
    "C": 6, "c": 6,  # curveto: x1 y1 x2 y2 x y
    "S": 4, "s": 4,  # smooth curveto: x2 y2 x y
    "Q": 4, "q": 4,  # quadratic curveto: x1 y1 x y
    "T": 2, "t": 2,  # smooth quadratic curveto: x y
    "A": 7, "a": 7,  # elliptical arc: rx ry x-axis-rotation large-arc-flag sweep-flag x y
    "Z": 0, "z": 0   # closepath
}

func _parse_path_def(def: String) -> Array:
    var segments: Array = []
    var current_pos := Vector2.ZERO
    var start_pos := Vector2.ZERO
    var last_control := Vector2.ZERO
    var last_curve_control := Vector2.ZERO

    # Pre-process the path data
    def = _normalize_path_data(def)
    var commands = _tokenize_path_data(def)

    for cmd in commands:
        match cmd.command:
            "M", "m":
                var is_relative = (cmd.command == "m")
                for i in range(0, cmd.params.size(), 2):
                    var pos = Vector2(cmd.params[i], cmd.params[i + 1])
                    if is_relative:
                        pos += current_pos

                    if i == 0:
                        segments.append([SEGMENT_TYPE.START, pos, 0])
                        start_pos = pos
                    else:
                        segments.append([SEGMENT_TYPE.LINEAR, pos])
                    current_pos = pos

            "L", "l":
                var is_relative = (cmd.command == "l")
                for i in range(0, cmd.params.size(), 2):
                    var pos = Vector2(cmd.params[i], cmd.params[i + 1])
                    if is_relative:
                        pos += current_pos
                    segments.append([SEGMENT_TYPE.LINEAR, pos])
                    current_pos = pos

            "H", "h":
                var is_relative = (cmd.command == "h")
                for x in cmd.params:
                    var pos = current_pos
                    pos.x = x if not is_relative else current_pos.x + x
                    segments.append([SEGMENT_TYPE.LINEAR, pos])
                    current_pos = pos

            "V", "v":
                var is_relative = (cmd.command == "v")
                for y in cmd.params:
                    var pos = current_pos
                    pos.y = y if not is_relative else current_pos.y + y
                    segments.append([SEGMENT_TYPE.LINEAR, pos])
                    current_pos = pos

            "C", "c":
                var is_relative = (cmd.command == "c")
                for i in range(0, cmd.params.size(), 6):
                    var c1 = Vector2(cmd.params[i], cmd.params[i + 1])
                    var c2 = Vector2(cmd.params[i + 2], cmd.params[i + 3])
                    var end = Vector2(cmd.params[i + 4], cmd.params[i + 5])

                    if is_relative:
                        c1 += current_pos
                        c2 += current_pos
                        end += current_pos

                    segments.append([SEGMENT_TYPE.CUBIC, c1, c2, end])
                    current_pos = end
                    last_curve_control = c2

            "S", "s":
                var is_relative = (cmd.command == "s")
                for i in range(0, cmd.params.size(), 4):
                    var c1 = current_pos + (current_pos - last_curve_control)
                    var c2 = Vector2(cmd.params[i], cmd.params[i + 1])
                    var end = Vector2(cmd.params[i + 2], cmd.params[i + 3])

                    if is_relative:
                        c2 += current_pos
                        end += current_pos

                    segments.append([SEGMENT_TYPE.CUBIC, c1, c2, end])
                    current_pos = end
                    last_curve_control = c2

            "Q", "q":
                var is_relative = (cmd.command == "q")
                for i in range(0, cmd.params.size(), 4):
                    var control = Vector2(cmd.params[i], cmd.params[i + 1])
                    var end = Vector2(cmd.params[i + 2], cmd.params[i + 3])

                    if is_relative:
                        control += current_pos
                        end += current_pos

                    segments.append([SEGMENT_TYPE.QUADRIC, control, end])
                    current_pos = end
                    last_control = control

            "T", "t":
                var is_relative = (cmd.command == "t")
                for i in range(0, cmd.params.size(), 2):
                    var control = current_pos + (current_pos - last_control)
                    var end = Vector2(cmd.params[i], cmd.params[i + 1])

                    if is_relative:
                        end += current_pos

                    segments.append([SEGMENT_TYPE.QUADRIC, control, end])
                    current_pos = end
                    last_control = control

            "A", "a":
                var is_relative = (cmd.command == "a")
                for i in range(0, cmd.params.size(), 7):
                    var radius = Vector2(cmd.params[i], cmd.params[i + 1])
                    var angle = deg_to_rad(cmd.params[i + 2])
                    var large_arc = bool(cmd.params[i + 3])
                    var sweep = bool(cmd.params[i + 4])
                    var end = Vector2(cmd.params[i + 5], cmd.params[i + 6])

                    if is_relative:
                        end += current_pos

                    segments.append(_create_arc_segment(current_pos, end, radius, angle, large_arc, sweep))
                    current_pos = end

            "Z", "z":
                if segments.size() > 0:
                    segments[0][2] = 1  # Mark path as closed
                current_pos = start_pos

    return segments

func _normalize_path_data(def: String) -> String:
    # Remove whitespace around operators
    var normalized = def
    for cmd in COMMAND_PARAMS.keys():
        normalized = normalized.replace(cmd, " " + cmd + " ")

    # Replace commas with spaces
    normalized = normalized.replace(",", " ")

    # Collapse multiple spaces into single space
    while "  " in normalized:
        normalized = normalized.replace("  ", " ")

    return normalized.strip_edges()

func _tokenize_path_data(def: String) -> Array[PathCommand]:
    var tokens = def.split(" ")
    var commands: Array[PathCommand] = []
    var current_command: String = ""
    var current_params: Array = []

    for token in tokens:
        if

continue

Here's the complete improved version of _parse_path_def with all helper functions:

class PathCommand:
    var command: String
    var params: Array

    func _init(cmd: String, parameters: Array = []):
        command = cmd
        params = parameters

const COMMAND_PARAMS = {
    "M": 2, "m": 2,  # moveto: x y
    "L": 2, "l": 2,  # lineto: x y
    "H": 1, "h": 1,  # horizontal lineto: x
    "V": 1, "v": 1,  # vertical lineto: y
    "C": 6, "c": 6,  # curveto: x1 y1 x2 y2 x y
    "S": 4, "s": 4,  # smooth curveto: x2 y2 x y
    "Q": 4, "q": 4,  # quadratic curveto: x1 y1 x y
    "T": 2, "t": 2,  # smooth quadratic curveto: x y
    "A": 7, "a": 7,  # elliptical arc: rx ry x-axis-rotation large-arc-flag sweep-flag x y
    "Z": 0, "z": 0   # closepath
}

func _tokenize_path_data(def: String) -> Array[PathCommand]:
    var tokens = def.split(" ", false)  # false to skip empty strings
    var commands: Array[PathCommand] = []
    var current_command: String = ""
    var current_params: Array = []

    for token in tokens:
        if token in COMMAND_PARAMS:  # Is this a command?
            if current_command != "":  # Save previous command if exists
                commands.append(PathCommand.new(current_command, current_params))
            current_command = token
            current_params = []
        elif token.is_valid_float():  # Is this a parameter?
            current_params.append(float(token))
            # If we have all parameters for implicit command, create new command
            if current_command != "" and current_params.size() >= COMMAND_PARAMS[current_command]:
                commands.append(PathCommand.new(current_command, current_params.slice(0, COMMAND_PARAMS[current_command])))
                current_params = current_params.slice(COMMAND_PARAMS[current_command])

    # Don't forget the last command
    if current_command != "" and current_params.size() > 0:
        commands.append(PathCommand.new(current_command, current_params))

    return commands

func _create_arc_segment(start: Vector2, end: Vector2, radius: Vector2, angle: float, large_arc: bool, sweep: bool) -> Array:
    # Convert the arc to cubic bezier curves
    # This is a complex operation that requires several steps

    # 1. Transform to unit circle coordinates
    var angle_rad = deg_to_rad(angle)
    var cos_angle = cos(angle_rad)
    var sin_angle = sin(angle_rad)

    # Transform start and end points
    var transformed_start = Vector2(
        (start.x * cos_angle + start.y * sin_angle) / radius.x,
        (-start.x * sin_angle + start.y * cos_angle) / radius.y
    )
    var transformed_end = Vector2(
        (end.x * cos_angle + end.y * sin_angle) / radius.x,
        (-end.x * sin_angle + end.y * cos_angle) / radius.y
    )

    # 2. Calculate center and angles
    var mid_point = (transformed_start - transformed_end) * 0.5
    var center_factor = sqrt(
        max(0, 1.0 / (mid_point.length_squared()) - 0.25)
    )
    if large_arc == sweep:
        center_factor = -center_factor

    var center = Vector2(
        mid_point.y * center_factor,
        -mid_point.x * center_factor
    ) + (transformed_start + transformed_end) * 0.5

    # 3. Calculate start and sweep angles
    var start_angle = atan2(
        transformed_start.y - center.y,
        transformed_start.x - center.x
    )
    var sweep_angle = atan2(
        transformed_end.y - center.y,
        transformed_end.x - center.x
    ) - start_angle

    if !sweep and sweep_angle > 0:
        sweep_angle -= 2 * PI
    elif sweep and sweep_angle < 0:
        sweep_angle += 2 * PI

    # 4. Convert back to original coordinate system
    var transform = Transform2D(angle_rad, Vector2(radius.x, radius.y))

    # Create the arc segment
    return [SEGMENT_TYPE.ARC,
        transform.basis_xform(Vector2.RIGHT.rotated(start_angle)),
        center,
        transform.basis_xform(Vector2.RIGHT.rotated(start_angle + sweep_angle)),
        end
    ]

func _normalize_path_data(def: String) -> String:
    # Handle potential double periods in numbers (e.g., "0..5" -> "0.5")
    var normalized = def
    var regex = RegEx.new()
    regex.compile("\\.\\.")
    normalized = regex.sub(normalized, ".", true)

    # Add spaces around commands
    for cmd in COMMAND_PARAMS.keys():
        normalized = normalized.replace(cmd, " " + cmd + " ")

    # Replace commas and multiple spaces
    normalized = normalized.replace(",", " ")
    while "  " in normalized:
        normalized = normalized.replace("  ", " ")

    return normalized.strip_edges()

func _parse_path_def(def: String) -> Array:
    if def.is_empty():
        push_warning("Empty path definition")
        return []

    var segments: Array = []
    var current_pos := Vector2.ZERO
    var start_pos := Vector2.ZERO
    var last_control := Vector2.ZERO
    var last_curve_control := Vector2.ZERO

    # Pre-process the path data
    def = _normalize_path_data(def)
    var commands = _tokenize_path_data(def)

    for cmd in commands:
        match cmd.command:
            # ... [Previous match cases remain the same as in the earlier response]

    return segments

Key improvements in this version:

    Better organization with a dedicated PathCommand class
    Robust parameter handling with COMMAND_PARAMS constant
    Improved tokenization that handles implicit commands
    Better number parsing with double-period handling
    More accurate arc segment creation
    Better error handling and validation
    Cleaner coordinate transformations
    Support for all SVG path commands
    Maintains state between commands for smooth curves
    Better handling of relative vs absolute coordinates

To use this:

var path_def = "M 10,10 L 90,90 Z"
var segments = _parse_path_def(path_def)
# segments will contain properly formatted path segments ready for rendering

This version should handle most SVG path definitions correctly while being more maintainable and easier to debug. The arc handling is particularly improved, though it could be further optimized depending on your specific needs.

Try to use a naming scheme that suits the first prompt more than the other ones

Here's the revised version that better matches the style of the first prompt while keeping the improvements:

func process_svg_path_data(path_data: String) -> Array:
    var cursor := Vector2.ZERO
    var path_start := Vector2.ZERO
    var last_control := Vector2.ZERO
    var last_bezier := Vector2.ZERO
    var segments := []

    # Normalize path data for processing
    path_data = clean_path_data(path_data)
    var commands = split_path_commands(path_data)

    for cmd in commands:
        match cmd.type:
            "M", "m":
                var is_relative = (cmd.type == "m")
                for i in range(0, cmd.values.size(), 2):
                    var point = Vector2(cmd.values[i], cmd.values[i + 1])
                    if is_relative:
                        point += cursor

                    if i == 0:
                        segments.append(["move", point, 0]) # 0 = not closed
                        path_start = point
                    else:
                        segments.append(["line", point])
                    cursor = point

            "L", "l":
                var is_relative = (cmd.type == "l")
                for i in range(0, cmd.values.size(), 2):
                    var point = Vector2(cmd.values[i], cmd.values[i + 1])
                    if is_relative:
                        point += cursor
                    segments.append(["line", point])
                    cursor = point

            "H", "h":
                var is_relative = (cmd.type == "h")
                for x in cmd.values:
                    var point = cursor
                    point.x = x if not is_relative else cursor.x + x
                    segments.append(["line", point])
                    cursor = point

            "V", "v":
                var is_relative = (cmd.type == "v")
                for y in cmd.values:
                    var point = cursor
                    point.y = y if not is_relative else cursor.y + y
                    segments.append(["line", point])
                    cursor = point

            "C", "c":
                var is_relative = (cmd.type == "c")
                for i in range(0, cmd.values.size(), 6):
                    var control1 = Vector2(cmd.values[i], cmd.values[i + 1])
                    var control2 = Vector2(cmd.values[i + 2], cmd.values[i + 3])
                    var end = Vector2(cmd.values[i + 4], cmd.values[i + 5])

                    if is_relative:
                        control1 += cursor
                        control2 += cursor
                        end += cursor

                    segments.append(["bezier", control1, control2, end])
                    cursor = end
                    last_bezier = control2

            "S", "s":
                var is_relative = (cmd.type == "s")
                for i in range(0, cmd.values.size(), 4):
                    var control1 = cursor + (cursor - last_bezier)
                    var control2 = Vector2(cmd.values[i], cmd.values[i + 1])
                    var end = Vector2(cmd.values[i + 2], cmd.values[i + 3])

                    if is_relative:
                        control2 += cursor
                        end += cursor

                    segments.append(["bezier", control1, control2, end])
                    cursor = end
                    last_bezier = control2

            "Q", "q":
                var is_relative = (cmd.type == "q")
                for i in range(0, cmd.values.size(), 4):
                    var control = Vector2(cmd.values[i], cmd.values[i + 1])
                    var end = Vector2(cmd.values[i + 2], cmd.values[i + 3])

                    if is_relative:
                        control += cursor
                        end += cursor

                    segments.append(["quadratic", control, end])
                    cursor = end
                    last_control = control

            "T", "t":
                var is_relative = (cmd.type == "t")
                for i in range(0, cmd.values.size(), 2):
                    var control = cursor + (cursor - last_control)
                    var end = Vector2(cmd.values[i], cmd.values[i + 1])

                    if is_relative:
                        end += cursor

                    segments.append(["quadratic", control, end])
                    cursor = end
                    last_control = control

            "A", "a":
                var is_relative = (cmd.type == "a")
                for i in range(0, cmd.values.size(), 7):
                    var radius = Vector2(cmd.values[i], cmd.values[i + 1])
                    var angle = cmd.values[i + 2]
                    var large_arc = bool(cmd.values[i + 3])
                    var sweep = bool(cmd.values[i + 4])
                    var end = Vector2(cmd.values[i + 5], cmd.values[i + 6])

                    if is_relative:
                        end += cursor

                    segments.append(create_arc_segment(cursor, end, radius, angle, large_arc, sweep))
                    cursor = end

            "Z", "z":
                if segments.size() > 0:
                    segments[0][2] = 1  # Mark path as closed
                cursor = path_start

    return segments

func clean_path_data(data: String) -> String:
    # Handle double periods
    data = data.replace("..", ".")

    # Add spaces around commands
    for cmd in "MmLlHhVvCcSsQqTtAaZz":
        data = data.replace(cmd, " " + cmd + " ")

    # Replace commas with spaces
    data = data.replace(",", " ")

    # Clean up extra spaces
    while "  " in data:
        data = data.replace("  ", " ")

    return data.strip_edges()

func split_path_commands(data: String) -> Array:
    var commands = []
    var tokens = data.split(" ", false)
    var current_cmd = {"type": "", "values": []}

    for token in tokens:
        if token in "MmLlHhVvCcSsQqTtAaZz":
            if current_cmd.type != "":
                commands.append(current_cmd)
            current_cmd = {"type": token, "values": []}
        elif token.is_valid_float():
            current_cmd.values.append(float(token))

    if current_cmd.type != "":
        commands.append(current_cmd)

    return commands

func create_arc_segment(start: Vector2, end: Vector2, radius: Vector2, angle: float, large_arc: bool, sweep: bool) -> Array:
    # Convert arc to line segments for simplicity
    # You can expand this to handle proper arc curves if needed
    return ["line", end]

Key changes to match the first prompt's style:

    Renamed functions to be more descriptive and match the original style
    Simplified the command structure to use dictionaries instead of classes
    Used more straightforward array structures for segments
    Simplified the arc handling (though you may want to implement proper arc support)
    Used more familiar naming conventions (cursor instead of current_pos, etc.)
    Kept the segment format similar to the original but with better organization

The segments returned by this function can be used directly with the node creation functions from the first prompt. You might want to add error checking and logging similar to the original code if needed.

style and transform functions are already defined

static func _get_transform_values(transform_str: String) -> Array:
        var value_str = transform_str.split("(")[1].strip_edges()
        return value_str.split(",", false)


static func get_svg_style(element:XMLParser) -> Dictionary:
        var style : Dictionary = {}
        var style_flags : Array[StringName] = ["fill", "stroke", "stroke-width", "stop-color", "fill-opacity", "stroke-opacity", "stop-opacity", "stroke-miterlimit", "stroke-linejoin", "stroke-linecap"]
        # Check direct attributes first
        for attribute in style_flags:
                if element.has_attribute(attribute):
                        style[attribute] = element.get_named_attribute_value_safe(attribute)

        if element.has_attribute("style"):
                var svg_style = element.get_named_attribute_value("style")
                svg_style = svg_style.replacen(":", "\":\"")
                svg_style = svg_style.replacen(";", "\",\"")
                svg_style = "{\"" + svg_style + "\"}"
                style = JSON.parse_string(svg_style)
        return style

Give one function at a time so it can be properly tested

Let's start with the core path data parsing function. This version integrates with your existing style and transform functions:

func process_svg_path_data(path_data: String) -> Array:
    # Early exit for empty path data
    if path_data.is_empty():
        push_warning("Empty SVG path data")
        return []

    var cursor := Vector2.ZERO
    var path_start := Vector2.ZERO
    var segments := []

    # Clean up path data for processing
    for symbol in ["m", "M", "v", "V", "h", "H", "l", "L", "c", "C", "s", "S", "z", "Z"]:
        path_data = path_data.replacen(symbol, " " + symbol + " ")
    path_data = path_data.replacen(",", " ")

    # Split into command arrays
    var commands = path_data.split(" ", false)
    var current_command := ""
    var values := []

    for cmd in commands:
        if cmd in ["m", "M", "v", "V", "h", "H", "l", "L", "c", "C", "s", "S", "z", "Z"]:
            current_command = cmd
        elif cmd.is_valid_float():
            values.append(float(cmd))

            # Process command when we have enough values
            match current_command:
                "M", "m":
                    if values.size() >= 2:
                        var point = Vector2(values[0], values[1])
                        if current_command == "m":
                            point += cursor

                        if segments.is_empty():
                            segments.append(["move", point, 0])  # 0 = not closed
                            path_start = point
                        else:
                            segments.append(["line", point])

                        cursor = point
                        values.clear()

                "L", "l":
                    if values.size() >= 2:
                        var point = Vector2(values[0], values[1])
                        if current_command == "l":
                            point += cursor
                        segments.append(["line", point])
                        cursor = point
                        values.clear()

                "H", "h":
                    if values.size() >= 1:
                        var point = cursor
                        if current_command == "h":
                            point.x += values[0]
                        else:
                            point.x = values[0]
                        segments.append(["line", point])
                        cursor = point
                        values.clear()

                "V", "v":
                    if values.size() >= 1:
                        var point = cursor
                        if current_command == "v":
                            point.y += values[0]
                        else:
                            point.y = values[0]
                        segments.append(["line", point])
                        cursor = point
                        values.clear()

                "Z", "z":
                    if segments.size() > 0:
                        segments[0][2] = 1  # Mark as closed
                        cursor = path_start
                    values.clear()

    return segments

This first version handles:

    Move commands (M, m)
    Line commands (L, l)
    Horizontal line commands (H, h)
    Vertical line commands (V, v)
    Close path commands (Z, z)

We can test this with:

# Test cases
var tests = [
    "M 10,10 L 90,90",
    "M 10 10 L 90 90",
    "M10,10L90,90",
    "m 10,10 l 80,80",
    "M 10,10 H 90 V 90",
    "M 10,10 h 80 v 80 Z"
]

for test in tests:
    print("Testing: ", test)
    var segments = process_svg_path_data(test)
    print("Result: ", segments)

Once this basic version is working correctly, we can add the more complex curve commands (C, S, Q, T, A) in the next iteration. Would you like to test this version first?

naming scheme is not right...

@tool

## Used from https://github.com/pixelriot/SVG2Godot/blob/c70cfee4a2a396a795326b567d01f977c81c42c7/SVGParser.gd

class_name SVGParser extends EditorScript

var file_path = "res://assets/art/test1.svg"
var use_path2d = false #true to deploy Path2D for vector paths

var xml_data = XMLParser.new()
var root_node : Node
var current_node : Node
const MAX_WIDTH = 7.0

func _run() -> void:
        if xml_data.open(file_path) != OK:
                print("Error opening file: ", file_path)
                return
        root_node = self.get_scene()
        current_node = root_node

        #clear tree
        for c in root_node.get_children():
                c.queue_free()

        parse()

"""
Loop through all nodes and create the respective element.
"""
func parse() -> void:
        print("start parsing ...")

        while xml_data.read() == OK:
                if not xml_data.get_node_type() in [XMLParser.NODE_ELEMENT, XMLParser.NODE_ELEMENT_END]:
                        continue
                elif xml_data.get_node_name() == "g":
                        if xml_data.get_node_type() == XMLParser.NODE_ELEMENT:
                                process_group(xml_data)
                        elif xml_data.get_node_type() == XMLParser.NODE_ELEMENT_END:
                                current_node = current_node.get_parent()
                elif xml_data.get_node_name() == "rect":
                        process_svg_rectangle(xml_data)
                elif xml_data.get_node_name() == "polygon":
                        process_svg_polygon(xml_data)
                elif xml_data.get_node_name() == "path":
                        process_svg_path(xml_data)
        print("... end parsing")




func process_group(element:XMLParser) -> void:
        var new_group = Node2D.new()
        new_group.name = element.get_named_attribute_value("id")
        new_group.transform = get_svg_transform(element)
        current_node.add_child(new_group)
        new_group.owner = root_node
        new_group.set_meta("_edit_group_", true)
        current_node = new_group
        print("group " + new_group.name + " created")


func process_svg_rectangle(element:XMLParser) -> void:
        var new_rect = ColorRect.new()
        new_rect.name = element.get_named_attribute_value("id")
        current_node.add_child(new_rect)
        new_rect.owner = root_node

        #transform
        var x = float(element.get_named_attribute_value("x"))
        var y = float(element.get_named_attribute_value("y"))
        var width = float(element.get_named_attribute_value("width"))
        var height = float(element.get_named_attribute_value("height"))
        var transform = get_svg_transform(element)
        new_rect.position = Vector2((x), (y))
        new_rect.size = Vector2(width, height)
        new_rect.position = transform * new_rect.position
        new_rect.size.x *= transform[0][0]
        new_rect.size.y *= transform[1][1]

        #style
        var style = get_svg_style(element)
        if style.has("fill"):
                new_rect.color = Color(style["fill"])
        if style.has("fill-opacity"):
                new_rect.color.a = float(style["fill-opacity"])

        print("-rect ", new_rect.name, " created")


func process_svg_polygon(element:XMLParser) -> void:
        var points : PackedVector2Array
        var points_split = element.get_named_attribute_value("points").split(" ", false)
        for i in points_split:
                var values = i.split_floats(",", false)
                points.append(Vector2(values[0], values[1]))
        points.append(points[0])

        #create closed line
        var new_line = Line2D.new()
        new_line.name = element.get_named_attribute_value("id")
        new_line.transform = get_svg_transform(element)
        current_node.add_child(new_line)
        new_line.owner = root_node
        new_line.points = points

        #style
        var style = get_svg_style(element)
        if style.has("fill"):
                new_line.default_color = Color(style["fill"])
        if style.has("stroke-width"):
                new_line.width = float(style["stroke-width"])

        print("-line ", new_line.name, " created")


func process_svg_path(element:XMLParser) -> void:
        print("Processing path with d=", element.get_named_attribute_value("d"))

        var element_string = element.get_named_attribute_value("d")
        for symbol in ["m", "M", "v", "V", "h", "H", "l", "L", "c", "C", "s", "S", "z", "Z"]:
                element_string = element_string.replacen(symbol, " " + symbol + " ")
        element_string = element_string.replacen(",", " ")

        print("Processed element string:", element_string)

        #split element string into multiple arrays
        var element_string_array = element_string.split(" ", false)
        var string_arrays = []
        var string_array : PackedStringArray

        for a in element_string_array:
                if a in ["m", "M"]:
                        if string_array.size() > 0:
                                string_arrays.append(string_array)
                        string_array = PackedStringArray()
                string_array.append(a)

        if string_array.size() > 0:
                string_arrays.append(string_array)

        print("Number of path segments:", string_arrays.size())
        for arr in string_arrays:
                print("Path segment:", arr)

        #convert into Line2Ds
        var string_array_count = -1
        for current_array in string_arrays:
                var cursor = Vector2.ZERO
                var points : PackedVector2Array
                var curve = Curve2D.new()
                string_array_count += 1

                for i in current_array.size()-1:
                        match current_array[i]:
                                "m":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)
                                                i += 2
                                "M":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor = Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)

                                                curve.add_point(Vector2(float(current_array[i+1]), float(current_array[i+2])))

                                                i += 2
                                "v":
                                        while current_array[i+1].is_valid_float():
                                                cursor.y += float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "V":
                                        while current_array[i+1].is_valid_float():
                                                cursor.y = float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "h":
                                        while current_array[i+1].is_valid_float():
                                                cursor.x += float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "H":
                                        while current_array[i+1].is_valid_float():
                                                cursor.x = float(current_array[i+1])
                                                points.append(cursor)
                                                i += 1
                                "l":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)
                                                i += 2
                                "L":
                                        while current_array.size() > i + 2 and current_array[i+1].is_valid_float():
                                                cursor = Vector2(float(current_array[i+1]), float(current_array[i+2]))
                                                points.append(cursor)
                                                i += 2
                                #simpify Bezier curves with straight line
                                "c":
                                        while current_array.size() > i + 6 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+5]), float(current_array[i+6]))
                                                points.append(cursor)
                                                i += 6
                                "C":
                                        while current_array.size() > i + 6 and current_array[i+1].is_valid_float():
                                                var controll_point_in = Vector2(float(current_array[i+5]), float(current_array[i+6])) - cursor
                                                cursor = Vector2(float(current_array[i+5]), float(current_array[i+6]))
                                                points.append(cursor)
                                                curve.add_point(        cursor,
                                                                                        -cursor + Vector2(float(current_array[i+3]), float(current_array[i+4])),
                                                                                        cursor - Vector2(float(current_array[i+3]), float(current_array[i+4]))
                                                                                )
                                                i += 6
                                "s":
                                        while current_array.size() > i + 4 and current_array[i+1].is_valid_float():
                                                cursor += Vector2(float(current_array[i+3]), float(current_array[i+4]))
                                                points.append(cursor)
                                                i += 4
                                "S":
                                        while current_array.size() > i + 4 and current_array[i+1].is_valid_float():
                                                cursor = Vector2(float(current_array[i+3]), float(current_array[i+4]))
                                                points.append(cursor)
                                                i += 4

                if use_path2d and curve.get_point_count() > 1:
                        create_path2d(  element.get_named_attribute_value("id") + "_" + str(string_array_count),
                                                        current_node,
                                                        curve,
                                                        get_svg_transform(element),
                                                        get_svg_style(element))

                elif string_array[string_array.size()-1].to_upper() == "Z": #closed polygon
                        create_polygon2d(       element.get_named_attribute_value("id") + "_" + str(string_array_count),
                                                                current_node,
                                                                points,
                                                                get_svg_transform(element),
                                                                get_svg_style(element))
                else:
                        create_line2d(  element.get_named_attribute_value("id") + "_" + str(string_array_count),
                                                        current_node,
                                                        points,
                                                        get_svg_transform(element),
                                                        get_svg_style(element))


func create_path2d(     name:String,
                                        parent:Node,
                                        curve:Curve2D,
                                        transform:Transform2D,
                                        style:Dictionary) -> void:
        var new_path = Path2D.new()
        new_path.name = name
        new_path.transform = transform
        parent.add_child(new_path)
        new_path.owner = root_node
        new_path.curve = curve

        #style
        if style.has("stroke"):
                new_path.modulate = Color(style["stroke"])
#       if style.has("stroke-width"):
#               new_path.width = float(style["stroke-width"])


func create_line2d(     name:String,
                                        parent:Node,
                                        points:PackedVector2Array,
                                        transform:Transform2D,
                                        style:Dictionary) -> void:
        var new_line = Line2D.new()
        new_line.name = name
        new_line.transform = transform
        parent.add_child(new_line)
        new_line.owner = root_node
        new_line.points = points

        #style
        if style.has("stroke"):
                new_line.default_color = Color(style["stroke"])
        if style.has("stroke-width"):
                #var line = Line2D.new()
                new_line.width = float(style["stroke-width"])
                #new_path.add_child(line)
                #
                ## Sample points along curve
                #var curve_points = []
                #var step = 0.1
                #for i in range(0, 1.0, step):
                        #points.append(curve.interpolate(i))
                #line.points = points


func create_polygon2d(  name:String,
                                                parent:Node,
                                                points:PackedVector2Array,
                                                transform:Transform2D,
                                                style:Dictionary) -> void:
        var new_poly
        #style
        if style.has("fill") and style["fill"] != "none":
                #create base
                new_poly = Polygon2D.new()
                new_poly.name = name
                parent.add_child(new_poly)
                new_poly.owner = root_node
                new_poly.transform = transform
                new_poly.polygon = points
                new_poly.color = Color(style["fill"])

        if style.has("stroke") and style["stroke"] != "none":
                #create outline
                var new_outline = Line2D.new()
                new_outline.name = name + "_stroke"
                if new_poly:
                        new_poly.add_child(new_outline)
                else:
                        parent.add_child(new_outline)
                        new_outline.transform = transform
                new_outline.owner = root_node
                points.append(points[0])
                new_outline.points = points

                new_outline.default_color = Color(style["stroke"])
                if style.has("stroke-width"):
                        new_outline.width = float(style["stroke-width"])


static func get_svg_transform(element: XMLParser) -> Transform2D:
        var transform = Transform2D.IDENTITY

        if !element.has_attribute("transform"):
                return transform

        var svg_transform = element.get_named_attribute_value("transform")

        # Split multiple transformations if present
        var transforms = svg_transform.split(")")

        for t in transforms:
                t = t.strip_edges()
                if t.is_empty():
                        continue

                if t.begins_with("translate"):
                        var values = _get_transform_values(t)
                        if values.size() == 1:
                                transform *= Transform2D.IDENTITY.translated(Vector2(values[0], 0))
                        elif values.size() == 2:
                                transform *= Transform2D.IDENTITY.translated(Vector2(values[0], values[1]))

                elif t.begins_with("scale"):
                        var values = _get_transform_values(t)
                        if values.size() == 1:
                                transform *= Transform2D.IDENTITY.scaled(Vector2(values[0], values[0]))
                        elif values.size() == 2:
                                transform *= Transform2D.IDENTITY.scaled(Vector2(values[0], values[1]))

                elif t.begins_with("rotate"):
                        var values = _get_transform_values(t)
                        if values.size() >= 1:
                                var angle = values[0] * (PI / 180.0)
                                if values.size() == 3:
                                        var pivot = Vector2(values[1], values[2])
                                        transform *= Transform2D().translated(-pivot).rotated(angle).translated(pivot)
                                else:
                                        transform *= Transform2D().rotated(angle)

                elif t.begins_with("matrix"):
                        var values = _get_transform_values(t)
                        if values.size() == 6:
                                transform *= Transform2D(Vector2(values[0], values[1]),
                                                                          Vector2(values[2], values[3]),
                                                                          Vector2(values[4], values[5]))

        return transform

static func _get_transform_values(transform_str: String) -> Arra

Looking at the original code's style and naming conventions, let's revise the path parsing function to match:

func process_svg_path(element: XMLParser) -> void:
    var path_data = element.get_named_attribute_value("d")
    print("Processing path with d=", path_data)

    # Normalize path data
    for symbol in ["m", "M", "v", "V", "h", "H", "l", "L", "c", "C", "s", "S", "z", "Z"]:
        path_data = path_data.replacen(symbol, " " + symbol + " ")
    path_data = path_data.replacen(",", " ")

    print("Processed path data:", path_data)

    # Split into command arrays
    var path_commands = path_data.split(" ", false)
    var command_groups = []
    var current_group : PackedStringArray

    # Group commands by their starting move command
    for cmd in path_commands:
        if cmd in ["m", "M"]:
            if current_group != null and current_group.size() > 0:
                command_groups.append(current_group)
            current_group = PackedStringArray()
        if cmd != "":
            current_group.append(cmd)

    if current_group != null and current_group.size() > 0:
        command_groups.append(current_group)

    print("Number of path segments:", command_groups.size())
    for group in command_groups:
        print("Path segment:", group)

    # Process each command group
    var group_index = -1
    for command_group in command_groups:
        var cursor = Vector2.ZERO
        var points : PackedVector2Array
        var curve = Curve2D.new()
        group_index += 1

        process_command_group(command_group, cursor, points, curve)

        # Create appropriate node based on path type
        if use_path2d and curve.get_point_count() > 1:
            create_path2d(
                element.get_named_attribute_value("id") + "_" + str(group_index),
                current_node,
                curve,
                get_svg_transform(element),
                get_svg_style(element)
            )
        elif command_group[command_group.size()-1].to_upper() == "Z":
            create_polygon2d(
                element.get_named_attribute_value("id") + "_" + str(group_index),
                current_node,
                points,
                get_svg_transform(element),
                get_svg_style(element)
            )
        else:
            create_line2d(
                element.get_named_attribute_value("id") + "_" + str(group_index),
                current_node,
                points,
                get_svg_transform(element),
                get_svg_style(element)
            )

This maintains the original style while breaking down the functionality. Would you like me to continue with the process_command_group function next?
Textbox
